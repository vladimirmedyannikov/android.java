/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the AnnotatedSQL library.
  */
package ru.mos.polls.db;

import android.content.ContentProvider;
import android.content.ContentProviderOperation;
import android.content.ContentProviderResult;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.OperationApplicationException;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.DatabaseUtils.InsertHelper;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.text.TextUtils;

import java.util.ArrayList;

import ru.mos.polls.R;


public class UserDataProvider extends ContentProvider{

    public static final String FRAGMENT_NO_NOTIFY = "no-notify";
    public static final String QUERY_LIMIT = "limit";
    public static final String QUERY_GROUP_BY = "groupBy";

    public static String AUTHORITY;
    public static Uri BASE_URI;

    protected final static int MATCH_TYPE_ITEM = 0x0001;
    protected final static int MATCH_TYPE_DIR = 0x0002;
    protected final static int MATCH_TYPE_MASK = 0x000f;

    protected final static int MATCH_CARS_URI_CONTENT = 0x1002;
    protected final static int MATCH_CARS_URI_CONTENT_ITEM = 0x1011;
    protected final static int MATCH_BLACKLIST_URI_CONTENT = 0x1022;
    protected final static int MATCH_BLACKLIST_URI_CONTENT_ITEM = 0x1031;
    protected final static int MATCH_TIMES_URI_CONTENT = 0x1042;
    protected final static int MATCH_TIMES_URI_CONTENT_ITEM = 0x1051;
    protected final static int MATCH_SUBSCRIPTIONS_URI_CONTENT = 0x1062;
    protected final static int MATCH_SUBSCRIPTIONS_URI_CONTENT_ITEM = 0x1071;
    protected final static int MATCH_ROADS_URI_CONTENT = 0x1082;
    protected final static int MATCH_ROADS_URI_CONTENT_ITEM = 0x1091;
    protected final static int MATCH_ROADGROUPS_URI_CONTENT = 0x10a2;
    protected final static int MATCH_ROADGROUPS_URI_CONTENT_ITEM = 0x10b1;
    protected final static int MATCH_FLATS_URI_CONTENT = 0x10c2;
    protected final static int MATCH_FLATS_URI_CONTENT_ITEM = 0x10d1;
    protected final static int MATCH_ROADSFULL_URI_CONTENT = 0x10f2;

    protected static final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);

    protected SQLiteOpenHelper dbHelper;
    protected ContentResolver contentResolver;

    @Override
    public boolean onCreate() {
        final Context context = getContext();
        dbHelper = new UserDataHelper(context);
        contentResolver = context.getContentResolver();
        if(AUTHORITY==null)
            generateStaticData(context);
        return true;
    }

    private static void generateStaticData(Context context){
        AUTHORITY = context.getString(R.string.elk_authority);
        BASE_URI = Uri.parse("content://" + AUTHORITY);

        matcher.addURI(AUTHORITY, UserData.Cars.URI_CONTENT, MATCH_CARS_URI_CONTENT);
        matcher.addURI(AUTHORITY, UserData.Cars.URI_CONTENT + "/#", MATCH_CARS_URI_CONTENT_ITEM);
        matcher.addURI(AUTHORITY, UserData.BlackList.URI_CONTENT, MATCH_BLACKLIST_URI_CONTENT);
        matcher.addURI(AUTHORITY, UserData.BlackList.URI_CONTENT + "/#", MATCH_BLACKLIST_URI_CONTENT_ITEM);
        matcher.addURI(AUTHORITY, UserData.Times.URI_CONTENT, MATCH_TIMES_URI_CONTENT);
        matcher.addURI(AUTHORITY, UserData.Times.URI_CONTENT + "/#", MATCH_TIMES_URI_CONTENT_ITEM);
        matcher.addURI(AUTHORITY, UserData.Subscriptions.URI_CONTENT, MATCH_SUBSCRIPTIONS_URI_CONTENT);
        matcher.addURI(AUTHORITY, UserData.Subscriptions.URI_CONTENT + "/#", MATCH_SUBSCRIPTIONS_URI_CONTENT_ITEM);
        matcher.addURI(AUTHORITY, UserData.Roads.URI_CONTENT, MATCH_ROADS_URI_CONTENT);
        matcher.addURI(AUTHORITY, UserData.Roads.URI_CONTENT + "/#", MATCH_ROADS_URI_CONTENT_ITEM);
        matcher.addURI(AUTHORITY, UserData.RoadGroups.URI_CONTENT, MATCH_ROADGROUPS_URI_CONTENT);
        matcher.addURI(AUTHORITY, UserData.RoadGroups.URI_CONTENT + "/#", MATCH_ROADGROUPS_URI_CONTENT_ITEM);
        matcher.addURI(AUTHORITY, UserData.Flats.URI_CONTENT, MATCH_FLATS_URI_CONTENT);
        matcher.addURI(AUTHORITY, UserData.Flats.URI_CONTENT + "/#", MATCH_FLATS_URI_CONTENT_ITEM);
        matcher.addURI(AUTHORITY, UserData.RoadsFull.URI_CONTENT, MATCH_ROADSFULL_URI_CONTENT);
    }

    @Override
    public String getType(Uri uri) {
        final String type;
        switch (matcher.match(uri) & MATCH_TYPE_MASK) {
            case MATCH_TYPE_ITEM:
                type = ContentResolver.CURSOR_ITEM_BASE_TYPE + "/vnd." + AUTHORITY + ".item";
                break;
            case MATCH_TYPE_DIR:
                type = ContentResolver.CURSOR_DIR_BASE_TYPE + "/vnd." + AUTHORITY + ".dir";
                break;
            default:
                throw new IllegalArgumentException("Unsupported uri " + uri);
        }
        return type;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        final SQLiteQueryBuilder query = new SQLiteQueryBuilder();
        switch (matcher.match(uri)) {
            case MATCH_CARS_URI_CONTENT:{
                query.setTables(UserData.Cars.TABLE_NAME);
                break;
            }
            case MATCH_CARS_URI_CONTENT_ITEM:{
                query.setTables(UserData.Cars.TABLE_NAME);
                query.appendWhere("_id = " + uri.getLastPathSegment());
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT:{
                query.setTables(UserData.BlackList.TABLE_NAME);
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT_ITEM:{
                query.setTables(UserData.BlackList.TABLE_NAME);
                query.appendWhere("_id = " + uri.getLastPathSegment());
                break;
            }
            case MATCH_TIMES_URI_CONTENT:{
                query.setTables(UserData.Times.TABLE_NAME);
                break;
            }
            case MATCH_TIMES_URI_CONTENT_ITEM:{
                query.setTables(UserData.Times.TABLE_NAME);
                query.appendWhere("_id = " + uri.getLastPathSegment());
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT:{
                query.setTables(UserData.Subscriptions.TABLE_NAME);
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT_ITEM:{
                query.setTables(UserData.Subscriptions.TABLE_NAME);
                query.appendWhere("_id = " + uri.getLastPathSegment());
                break;
            }
            case MATCH_ROADS_URI_CONTENT:{
                query.setTables(UserData.Roads.TABLE_NAME);
                break;
            }
            case MATCH_ROADS_URI_CONTENT_ITEM:{
                query.setTables(UserData.Roads.TABLE_NAME);
                query.appendWhere("_id = " + uri.getLastPathSegment());
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT:{
                query.setTables(UserData.RoadGroups.TABLE_NAME);
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT_ITEM:{
                query.setTables(UserData.RoadGroups.TABLE_NAME);
                query.appendWhere("_id = " + uri.getLastPathSegment());
                break;
            }
            case MATCH_FLATS_URI_CONTENT:{
                query.setTables(UserData.Flats.TABLE_NAME);
                break;
            }
            case MATCH_FLATS_URI_CONTENT_ITEM:{
                query.setTables(UserData.Flats.TABLE_NAME);
                query.appendWhere("_id = " + uri.getLastPathSegment());
                break;
            }
            case MATCH_ROADSFULL_URI_CONTENT:{
                Cursor c = dbHelper.getReadableDatabase().rawQuery(UserSchema.SQL_QUERY_ROADS_PATH
                        + (TextUtils.isEmpty(selection) ? "" : " where " + selection)
                        + (TextUtils.isEmpty(sortOrder) ? "" : " order by " + sortOrder)
                        , selectionArgs);
                c.setNotificationUri(getContext().getContentResolver(), uri);
                return c;
            }
            default:
                throw new IllegalArgumentException("Unsupported uri " + uri);
        }
        Cursor c = query.query(dbHelper.getReadableDatabase(),
                projection, selection, selectionArgs,
                uri.getQueryParameter(QUERY_GROUP_BY), null, sortOrder, uri.getQueryParameter(QUERY_LIMIT));
        c.setNotificationUri(getContext().getContentResolver(), uri);

        return c;
    }

    @Override
    public ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations) throws OperationApplicationException {
        SQLiteDatabase sql = dbHelper.getWritableDatabase();
        sql.beginTransaction();
        ContentProviderResult[] res = null;
        try{
            res = super.applyBatch(operations);
            sql.setTransactionSuccessful();
        }finally{
            sql.endTransaction();
        }
        return res;
    }


    @Override
    public int bulkInsert(Uri uri, ContentValues[] valuesAr) {
        final String table;

        switch(matcher.match(uri)){
            case MATCH_CARS_URI_CONTENT:{
                table = UserData.Cars.TABLE_NAME;
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT:{
                table = UserData.BlackList.TABLE_NAME;
                break;
            }
            case MATCH_TIMES_URI_CONTENT:{
                table = UserData.Times.TABLE_NAME;
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT:{
                table = UserData.Subscriptions.TABLE_NAME;
                break;
            }
            case MATCH_ROADS_URI_CONTENT:{
                table = UserData.Roads.TABLE_NAME;
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT:{
                table = UserData.RoadGroups.TABLE_NAME;
                break;
            }
            case MATCH_FLATS_URI_CONTENT:{
                table = UserData.Flats.TABLE_NAME;
                break;
            }
            default:
                throw new IllegalArgumentException("Unsupported uri " + uri);
        }
        SQLiteDatabase sql = dbHelper.getWritableDatabase();
        sql.beginTransaction();
        int count = 0;
        try {
            InsertHelper ih = new InsertHelper(sql, table);
            for (ContentValues values : valuesAr) {
                ih.replace(values);
                count++;
            }
            ih.close();
            sql.setTransactionSuccessful();
        } finally {
            sql.endTransaction();
        }

        if (!ignoreNotify(uri)) {
            notifyUri(contentResolver, uri);
        }
        return count;
    }

    @Override
    @SuppressWarnings("unused")
    public Uri insert(Uri uri, ContentValues values) {
        final String table;

        switch(matcher.match(uri)){
            case MATCH_CARS_URI_CONTENT:{
                table = UserData.Cars.TABLE_NAME;
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT:{
                table = UserData.BlackList.TABLE_NAME;
                break;
            }
            case MATCH_TIMES_URI_CONTENT:{
                table = UserData.Times.TABLE_NAME;
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT:{
                table = UserData.Subscriptions.TABLE_NAME;
                break;
            }
            case MATCH_ROADS_URI_CONTENT:{
                table = UserData.Roads.TABLE_NAME;
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT:{
                table = UserData.RoadGroups.TABLE_NAME;
                break;
            }
            case MATCH_FLATS_URI_CONTENT:{
                table = UserData.Flats.TABLE_NAME;
                break;
            }
            default:
                throw new IllegalArgumentException("Unsupported uri " + uri);
        }
        long id = dbHelper.getWritableDatabase().insertWithOnConflict(table, null, values, SQLiteDatabase.CONFLICT_REPLACE);
        if(!ignoreNotify(uri)){
            notifyUri(contentResolver, uri);
        }
        return Uri.withAppendedPath(uri, String.valueOf(id));
    }

    @Override
    @SuppressWarnings("unused")
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        final String table;
        String processedSelection = selection;

        switch(matcher.match(uri)){
            case MATCH_CARS_URI_CONTENT:{
                table = UserData.Cars.TABLE_NAME;
                break;
            }
            case MATCH_CARS_URI_CONTENT_ITEM:{
                table = UserData.Cars.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT:{
                table = UserData.BlackList.TABLE_NAME;
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT_ITEM:{
                table = UserData.BlackList.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_TIMES_URI_CONTENT:{
                table = UserData.Times.TABLE_NAME;
                break;
            }
            case MATCH_TIMES_URI_CONTENT_ITEM:{
                table = UserData.Times.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT:{
                table = UserData.Subscriptions.TABLE_NAME;
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT_ITEM:{
                table = UserData.Subscriptions.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_ROADS_URI_CONTENT:{
                table = UserData.Roads.TABLE_NAME;
                break;
            }
            case MATCH_ROADS_URI_CONTENT_ITEM:{
                table = UserData.Roads.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT:{
                table = UserData.RoadGroups.TABLE_NAME;
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT_ITEM:{
                table = UserData.RoadGroups.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_FLATS_URI_CONTENT:{
                table = UserData.Flats.TABLE_NAME;
                break;
            }
            case MATCH_FLATS_URI_CONTENT_ITEM:{
                table = UserData.Flats.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            default:
                throw new IllegalArgumentException("Unsupported uri " + uri);
        }
        int count = dbHelper.getWritableDatabase().update(table, values, processedSelection, selectionArgs);
        if(!ignoreNotify(uri)){
            notifyUri(contentResolver, uri);
        }

        return count;
    }

    @Override
    @SuppressWarnings("unused")
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        final String table;
        String processedSelection = selection;

        switch(matcher.match(uri)){
            case MATCH_CARS_URI_CONTENT:{
                table = UserData.Cars.TABLE_NAME;
                break;
            }
            case MATCH_CARS_URI_CONTENT_ITEM:{
                table = UserData.Cars.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT:{
                table = UserData.BlackList.TABLE_NAME;
                break;
            }
            case MATCH_BLACKLIST_URI_CONTENT_ITEM:{
                table = UserData.BlackList.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_TIMES_URI_CONTENT:{
                table = UserData.Times.TABLE_NAME;
                break;
            }
            case MATCH_TIMES_URI_CONTENT_ITEM:{
                table = UserData.Times.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT:{
                table = UserData.Subscriptions.TABLE_NAME;
                break;
            }
            case MATCH_SUBSCRIPTIONS_URI_CONTENT_ITEM:{
                table = UserData.Subscriptions.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_ROADS_URI_CONTENT:{
                table = UserData.Roads.TABLE_NAME;
                break;
            }
            case MATCH_ROADS_URI_CONTENT_ITEM:{
                table = UserData.Roads.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT:{
                table = UserData.RoadGroups.TABLE_NAME;
                break;
            }
            case MATCH_ROADGROUPS_URI_CONTENT_ITEM:{
                table = UserData.RoadGroups.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            case MATCH_FLATS_URI_CONTENT:{
                table = UserData.Flats.TABLE_NAME;
                break;
            }
            case MATCH_FLATS_URI_CONTENT_ITEM:{
                table = UserData.Flats.TABLE_NAME;
                processedSelection = composeIdSelection(selection, uri.getLastPathSegment(), "_id");
                break;
            }
            default:
                throw new IllegalArgumentException("Unsupported uri " + uri);
        }
        int count = dbHelper.getWritableDatabase().delete(table, processedSelection, selectionArgs);
        if(!ignoreNotify(uri)){
            notifyUri(contentResolver, uri);
        }
        return count;
    }

    public static void notifyUri(ContentResolver cr, Uri uri){
        cr.notifyChange(uri, null);
        switch(matcher.match(uri)){
        }
    }

    protected static boolean ignoreNotify(Uri uri){
        return FRAGMENT_NO_NOTIFY.equals(uri.getFragment());
    }

    protected String composeIdSelection(String originalSelection, String id, String idColumn) {
        StringBuffer sb = new StringBuffer();
        sb.append(idColumn).append('=').append(id);
        if (!TextUtils.isEmpty(originalSelection)) {
            sb.append(" AND (").append(originalSelection).append(')');
        }
        return sb.toString();
    }

    public static Uri getContentUri(String path){
        if(TextUtils.isEmpty(path))
            return null;
        return BASE_URI.buildUpon().appendPath(path).build();
    }

    public static Uri getContentUriGroupBy(String path, String groupBy){
        if(TextUtils.isEmpty(path))
            return null;
        return BASE_URI.buildUpon().appendPath(path).appendQueryParameter(QUERY_GROUP_BY, groupBy).build();
    }

    public static Uri getContentUri(String path, long id){
        if(TextUtils.isEmpty(path))
            return null;
        return BASE_URI.buildUpon().appendPath(path).appendPath(String.valueOf(id)).build();
    }

    public static Uri getContentUri(String path, String id){
        if(TextUtils.isEmpty(path))
            return null;
        return BASE_URI.buildUpon().appendPath(path).appendPath(id).build();
    }

    public static Uri getContentWithLimitUri(String path, int limit){
        if(TextUtils.isEmpty(path))
            return null;
        return BASE_URI.buildUpon().appendPath(path).appendQueryParameter(QUERY_LIMIT, String.valueOf(limit)).build();
    }

    public static Uri getNoNotifyContentUri(String path){
        if(TextUtils.isEmpty(path))
            return null;
        return BASE_URI.buildUpon().appendPath(path).fragment(FRAGMENT_NO_NOTIFY).build();
    }

    public static Uri getNoNotifyContentUri(String path, long id){
        if(TextUtils.isEmpty(path))
            return null;
        return BASE_URI.buildUpon().appendPath(path).appendPath(String.valueOf(id)).fragment(FRAGMENT_NO_NOTIFY).build();
    }


}
